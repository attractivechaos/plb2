struct SudokuSolver {
mut:
	r [324][9]u16
	c [729][4]u16
}

@[direct_array_access]
fn ss_init() &SudokuSolver {
	mut ss := SudokuSolver{
		r: [324][9]u16{}
		c: [729][4]u16{}
	}
	mut p := 0
	for i in 0 .. 9 {
		for j in 0 .. 9 {
			for k in 0 .. 9 {
				ss.c[p][0] = 9 * i + j
				ss.c[p][1] = (i / 3 * 3 + j / 3) * 9 + k + 81
				ss.c[p][2] = 9 * i + k + 162
				ss.c[p][3] = 9 * j + k + 243
				p += 1
			}
		}
	}
	mut nr := [324]u8{}
	for r in 0 .. 729 {
		for c2 in 0 .. 4 {
			c := ss.c[r][c2]
			ss.r[c][nr[c]] = r
			nr[c] += 1
		}
	}
	return &ss
}

@[direct_array_access]
fn ss_update_for(ss &SudokuSolver, mut sr [729]i8, mut sc [324]u8, r u16) u32 {
	mut min := u8(10)
	mut min_c := u16(0)
	for c in ss.c[r] {
		sc[c] |= 0x80
	}
	for c in ss.c[r] {
		for rr in ss.r[c] {
			sr[rr]++
			if sr[rr] != 1 {
				continue
			}
			for cc in ss.c[rr] {
				v := sc[cc] - 1
				sc[cc] = v
				if v < min {
					min, min_c = v, cc
				}
			}
		}
	}
	return u32(min) << 16 | u32(min_c)
}

@[direct_array_access]
fn ss_update_rev(ss &SudokuSolver, mut sr [729]i8, mut sc [324]u8, r u16) {
	for c in ss.c[r] {
		sc[c] &= 0x7f
	}
	for c in ss.c[r] {
		for rr in ss.r[c] {
			sr[rr]--
			if sr[rr] != 0 {
				continue
			}
			for cc in ss.c[rr] {
				sc[cc]++
			}
		}
	}
}

@[direct_array_access]
fn ss_solve(ss &SudokuSolver, s string) int {
	mut sr := [729]i8{}
	mut cr := [81]i8{}
	mut sc := [324]u8{}
	mut cc := [81]i16{}
	mut out := [81]u8{}
	mut n, mut hints := 0, 0
	for c := 0; c < 324; c++ {
		sc[c] = 9
	}
	for i := 0; i < 81; i++ {
		mut a := -1
		if s[i] >= 49 && s[i] <= 57 {
			a = i32(s[i] - 49)
		}
		if a >= 0 {
			ss_update_for(ss, mut sr, mut sc, u16(i * 9 + a))
			hints++
		}
		cr[i], cc[i], out[i] = -1, -1, s[i]
	}
	mut i, mut dir, mut cand := 0, 1, 10 << 16
	for {
		for i >= 0 && i < 81 - hints {
			if dir == 1 {
				mut min := u8(cand >> 16)
				cc[i] = i16(cand & 0xffff)
				if min > 1 {
					for c, scc in sc {
						if scc < min {
							min, cc[i] = scc, i16(c)
							if min <= 1 {
								break
							}
						}
					}
				}
				if min == 0 || min == 10 {
					cr[i], dir = -1, -1
					i--
				}
			}
			c := cc[i]
			if dir == -1 && cr[i] >= 0 {
				ss_update_rev(ss, mut sr, mut sc, ss.r[c][cr[i]])
			}
			mut r2 := cr[i] + 1
			for r2 < 9 && sr[ss.r[c][r2]] != 0 {
				r2++
			}
			if r2 < 9 {
				cand = ss_update_for(ss, mut sr, mut sc, ss.r[c][r2])
				cr[i], dir = i8(r2), 1
				i++
			} else {
				cr[i], dir = -1, -1
				i--
			}
		}
		if i < 0 {
			break
		}
		for j in 0 .. i {
			r := ss.r[cc[j]][cr[j]]
			out[r / 9] = u8(r % 9) + 49
		}
		println(out[..].bytestr())
		n++
		i--
		dir = -1
	}
	return n
}

fn main() {
	hard20 := [
		'..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9',
		'.......12........3..23..4....18....5.6..7.8.......9.....85.....9...4.5..47...6...',
		'.2..5.7..4..1....68....3...2....8..3.4..2.5.....6...1...2.9.....9......57.4...9..',
		'........3..1..56...9..4..7......9.5.7.......8.5.4.2....8..2..9...35..1..6........',
		'12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8',
		'1.......2.9.4...5...6...7...5.9.3.......7.......85..4.7.....6...3...9.8...2.....1',
		'.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....',
		'12.3.....4.....3....3.5......42..5......8...9.6...5.7...15..2......9..6......7..8',
		'..3..6.8....1..2......7...4..9..8.6..3..4...1.7.2.....3....5.....5...6..98.....5.',
		'1.......9..67...2..8....4......75.3...5..2....6.3......9....8..6...4...1..25...6.',
		'..9...4...7.3...2.8...6...71..8....6....1..7.....56...3....5..1.4.....9...2...7..',
		'....9..5..1.....3...23..7....45...7.8.....2.......64...9..1.....8..6......54....7',
		'4...3.......6..8..........1....5..9..8....6...7.2........1.27..5.3....4.9........',
		'7.8...3.....2.1...5.........4.....263...8.......1...9..9.6....4....7.5...........',
		'3.7.4...........918........4.....7.....16.......25..........38..9....5...2.6.....',
		'........8..3...4...9..2..6.....79.......612...6.5.2.7...8...5...1.....2.4.5.....3',
		'.......1.4.........2...........5.4.7..8...3....1.9....3..4..2...5.1........8.6...',
		'.......12....35......6...7.7.....3.....4..8..1...........12.....8.....4..5....6..',
		'1.......2.9.4...5...6...7...5.3.4.......6........58.4...2...6...3...9.8.7.......1',
		'.....1.2.3...4.5.....6....7..2.....1.8..9..3.4.....8..5....2....9..3.4....67.....',
	]
	ss := ss_init()
	mut n := 200
	for i := 0; i < n; i++ {
		for l in hard20 {
			ss_solve(ss, l)
			println('')
		}
	}
}
